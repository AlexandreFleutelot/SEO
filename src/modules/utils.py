# -*- coding: utf-8 -*-
"""
Utilitaires pour le calcul des scores et la g√©n√©ration de recommandations
Ce module centralise la logique de scoring et les conseils d'am√©lioration
"""

from typing import Dict, List, Any
from ..config import SCORING_THRESHOLDS


def calculer_score_global(analyses: Dict[str, Any]) -> Dict[str, Any]:
    """
    Calcule le score SEO global bas√© sur toutes les analyses
    
    Args:
        analyses: Dictionnaire contenant toutes les analyses
        
    Returns:
        dict: Score global et d√©tails par cat√©gorie
    """
    print("üßÆ Calcul des scores SEO...")
    
    scores_categories = {}
    
    # === CONTENU (35% du score) ===
    if 'contenu' in analyses:
        score_contenu = calculer_score_contenu(analyses['contenu'])
        scores_categories['contenu'] = score_contenu
    
    # === STRUCTURE (25% du score) ===
    if 'structure' in analyses:
        score_structure = calculer_score_structure(analyses['structure'])
        scores_categories['structure'] = score_structure
    
    # === PERFORMANCE (25% du score) ===
    if 'performance' in analyses:
        score_performance = analyses['performance'].get('score_performance_global', 50)
        scores_categories['performance'] = score_performance
    
    # === MAILLAGE (15% du score) ===
    if 'maillage' in analyses:
        score_maillage = calculer_score_maillage(analyses['maillage'])
        scores_categories['maillage'] = score_maillage
    
    # Calculer le score global pond√©r√©
    poids = {
        'contenu': 0.35,
        'structure': 0.25,
        'performance': 0.25,
        'maillage': 0.15
    }
    
    score_global = 0
    total_poids = 0
    
    for categorie, score in scores_categories.items():
        if score > 0:  # Ignorer les scores nuls (analyses √©chou√©es)
            score_global += score * poids.get(categorie, 0)
            total_poids += poids.get(categorie, 0)
    
    # Normaliser si certaines analyses ont √©chou√©
    if total_poids > 0:
        score_global = score_global / total_poids
    else:
        score_global = 0
    
    # D√©terminer le niveau de performance
    niveau_performance = determiner_niveau_performance(score_global)
    
    # Identifier les forces et faiblesses
    forces, faiblesses = identifier_forces_faiblesses(scores_categories)
    
    return {
        'score_global': round(score_global, 1),
        'niveau_performance': niveau_performance,
        'scores_categories': scores_categories,
        'forces': forces,
        'faiblesses': faiblesses,
        'details_scoring': {
            'poids_utilises': {k: v for k, v in poids.items() if k in scores_categories},
            'nombre_categories': len(scores_categories)
        }
    }


def calculer_score_contenu(analyse_contenu: Dict[str, Any]) -> int:
    """Calcule le score de la cat√©gorie contenu"""
    score = 0
    nombre_metriques = 0
    
    # Score de richesse
    if 'richesse_couverture' in analyse_contenu:
        richesse = analyse_contenu['richesse_couverture']
        if 'nombre_mots' in richesse:
            nb_mots = richesse['nombre_mots']
            if nb_mots >= 1500:
                score += 90
            elif nb_mots >= 1000:
                score += 75
            elif nb_mots >= 500:
                score += 60
            elif nb_mots >= 300:
                score += 45
            else:
                score += 20
            nombre_metriques += 1
        
        if 'nombre_entites' in richesse:
            nb_entites = richesse['nombre_entites']
            if nb_entites >= 20:
                score += 85
            elif nb_entites >= 10:
                score += 70
            elif nb_entites >= 5:
                score += 50
            else:
                score += 30
            nombre_metriques += 1
    
    # Score de lisibilit√©
    if 'style_clarte' in analyse_contenu:
        style = analyse_contenu['style_clarte']
        if 'lisibilite_score' in style:
            score += style['lisibilite_score']
            nombre_metriques += 1
    
    # Score de cr√©dibilit√©
    if 'sources_fiabilite' in analyse_contenu:
        sources = analyse_contenu['sources_fiabilite']
        if 'score_credibilite' in sources:
            score += sources['score_credibilite']
            nombre_metriques += 1
    
    # Score de fra√Æcheur
    if 'fraicheur' in analyse_contenu:
        fraicheur = analyse_contenu['fraicheur']
        if 'score_fraicheur' in fraicheur:
            score += fraicheur['score_fraicheur']
            nombre_metriques += 1
    
    # Score de naturalit√© (anti-IA)
    if 'detection_ia' in analyse_contenu:
        ia = analyse_contenu['detection_ia']
        if 'score_naturel' in ia:
            score += ia['score_naturel']
            nombre_metriques += 1
    
    return round(score / nombre_metriques) if nombre_metriques > 0 else 0


def calculer_score_structure(analyse_structure: Dict[str, Any]) -> int:
    """Calcule le score de la cat√©gorie structure"""
    score = 0
    nombre_metriques = 0
    
    # Score des titres
    if 'structure_titres' in analyse_structure:
        titres = analyse_structure['structure_titres']
        if 'score_structure_titres' in titres:
            score += titres['score_structure_titres']
            nombre_metriques += 1
    
    # Score des m√©tadonn√©es
    if 'metadonnees' in analyse_structure:
        meta = analyse_structure['metadonnees']
        if 'score_metadonnees' in meta:
            score += meta['score_metadonnees']
            nombre_metriques += 1
    
    # Score des images
    if 'images' in analyse_structure:
        images = analyse_structure['images']
        if 'score_images' in images:
            score += images['score_images']
            nombre_metriques += 1
    
    # Score des donn√©es structur√©es
    if 'donnees_structurees' in analyse_structure:
        schema = analyse_structure['donnees_structurees']
        if 'score_donnees_structurees' in schema:
            score += schema['score_donnees_structurees']
            nombre_metriques += 1
    
    # Score de crawlabilit√©
    if 'crawlabilite' in analyse_structure:
        crawl = analyse_structure['crawlabilite']
        if 'score_crawlabilite' in crawl:
            score += crawl['score_crawlabilite']
            nombre_metriques += 1
    
    return round(score / nombre_metriques) if nombre_metriques > 0 else 0


def calculer_score_maillage(analyse_maillage: Dict[str, Any]) -> int:
    """Calcule le score de la cat√©gorie maillage interne"""
    # Score par d√©faut si pas d'analyse de maillage
    return 60


def determiner_niveau_performance(score: float) -> str:
    """D√©termine le niveau de performance bas√© sur le score"""
    if score >= SCORING_THRESHOLDS['excellent']:
        return "Excellent"
    elif score >= SCORING_THRESHOLDS['bon']:
        return "Bon"
    elif score >= SCORING_THRESHOLDS['moyen']:
        return "Moyen"
    else:
        return "Faible"


def identifier_forces_faiblesses(scores: Dict[str, int]) -> tuple:
    """Identifie les forces et faiblesses bas√©es sur les scores"""
    forces = []
    faiblesses = []
    
    for categorie, score in scores.items():
        nom_categorie = nom_convivial_categorie(categorie)
        
        if score >= SCORING_THRESHOLDS['excellent']:
            forces.append(nom_categorie)
        elif score < SCORING_THRESHOLDS['moyen']:
            faiblesses.append(nom_categorie)
    
    return forces, faiblesses


def nom_convivial_categorie(categorie: str) -> str:
    """Convertit le nom technique en nom convivial"""
    mapping = {
        'contenu': 'Contenu & S√©mantique',
        'structure': 'Structure Technique', 
        'performance': 'Performance & Vitesse',
        'maillage': 'Maillage Interne'
    }
    return mapping.get(categorie, categorie.title())


def generer_recommandations(analyses: Dict[str, Any], scores: Dict[str, Any]) -> Dict[str, List[str]]:
    """
    G√©n√®re des recommandations personnalis√©es bas√©es sur les analyses
    
    Args:
        analyses: Toutes les analyses effectu√©es
        scores: Scores calcul√©s par cat√©gorie
        
    Returns:
        dict: Recommandations organis√©es par cat√©gorie
    """
    print("üí° G√©n√©ration des recommandations...")
    
    recommandations = {
        'contenu': [],
        'structure': [],
        'performance': [],
        'maillage': [],
        'prioritaires': []
    }
    
    # === RECOMMANDATIONS CONTENU ===
    if 'contenu' in analyses:
        reco_contenu = generer_recommandations_contenu(analyses['contenu'])
        recommandations['contenu'].extend(reco_contenu)
    
    # === RECOMMANDATIONS STRUCTURE ===
    if 'structure' in analyses:
        reco_structure = generer_recommandations_structure(analyses['structure'])
        recommandations['structure'].extend(reco_structure)
    
    # === RECOMMANDATIONS PERFORMANCE ===
    if 'performance' in analyses:
        reco_performance = generer_recommandations_performance(analyses['performance'])
        recommandations['performance'].extend(reco_performance)
    
    # === RECOMMANDATIONS PRIORITAIRES ===
    score_global = scores.get('score_global', 0)
    if score_global < 50:
        recommandations['prioritaires'].append(
            "üî• URGENT: Score global faible - concentrez-vous sur les faiblesses identifi√©es"
        )
    
    # Identifier les 3 recommandations les plus importantes
    toutes_reco = []
    for categorie, reco_list in recommandations.items():
        if categorie != 'prioritaires':
            toutes_reco.extend(reco_list[:2])  # Max 2 par cat√©gorie
    
    if len(toutes_reco) >= 3:
        recommandations['prioritaires'].extend(toutes_reco[:3])
    
    print("‚úÖ Recommandations g√©n√©r√©es")
    return recommandations


def generer_recommandations_contenu(analyse_contenu: Dict[str, Any]) -> List[str]:
    """G√©n√®re des recommandations pour le contenu"""
    recommendations = []
    
    # Richesse du contenu
    if 'richesse_couverture' in analyse_contenu:
        richesse = analyse_contenu['richesse_couverture']
        
        if 'nombre_mots' in richesse:
            nb_mots = richesse['nombre_mots']
            if nb_mots < 300:
                recommendations.append("üìù Enrichir le contenu : ajouter au moins 300 mots pour am√©liorer la pertinence SEO")
            elif nb_mots < 800:
                recommendations.append("üìà D√©velopper le contenu : viser 800-1500 mots pour un meilleur positionnement")
        
        if 'nombre_entites' in richesse and richesse['nombre_entites'] < 5:
            recommendations.append("üè∑Ô∏è Ajouter plus d'entit√©s nomm√©es (personnes, lieux, organisations) pour enrichir la s√©mantique")
    
    # Lisibilit√©
    if 'style_clarte' in analyse_contenu:
        style = analyse_contenu['style_clarte']
        
        if 'nombre_listes' in style and style['nombre_listes'] == 0:
            recommendations.append("üìã Structurer avec des listes √† puces pour am√©liorer la lisibilit√©")
        
        if 'longueur_moyenne_phrase' in style and style['longueur_moyenne_phrase'] > 25:
            recommendations.append("‚úÇÔ∏è Raccourcir les phrases (actuellement > 25 mots) pour une meilleure lisibilit√©")
    
    # Sources et cr√©dibilit√©
    if 'sources_fiabilite' in analyse_contenu:
        sources = analyse_contenu['sources_fiabilite']
        
        if 'sources_fiables' in sources and sources['sources_fiables'] == 0:
            recommendations.append("üîó Ajouter des liens vers des sources fiables (.gouv, .edu, organisations reconnues)")
        
        if 'citations_textuelles' in sources and sources['citations_textuelles'] == 0:
            recommendations.append("üìö Inclure des citations et r√©f√©rences pour renforcer la cr√©dibilit√©")
    
    # Fra√Æcheur
    if 'fraicheur' in analyse_contenu:
        fraicheur = analyse_contenu['fraicheur']
        
        if fraicheur.get('niveau_fraicheur') == 'ancien':
            recommendations.append("üîÑ Mettre √† jour le contenu : les informations semblent anciennes")
        elif fraicheur.get('jours_depuis_maj') is None:
            recommendations.append("üìÖ Ajouter une date de publication/mise √† jour visible")
    
    # D√©tection IA
    if 'detection_ia' in analyse_contenu:
        ia = analyse_contenu['detection_ia']
        
        if ia.get('score_naturel', 100) < 60:
            recommendations.append("‚úçÔ∏è Humaniser le contenu : le texte semble trop g√©n√©r√© par IA, ajouter plus de personnalit√©")
    
    return recommendations[:5]  # Limiter √† 5 recommandations max


def generer_recommandations_structure(analyse_structure: Dict[str, Any]) -> List[str]:
    """G√©n√®re des recommandations pour la structure"""
    recommendations = []
    
    # Structure des titres
    if 'structure_titres' in analyse_structure:
        titres = analyse_structure['structure_titres']
        
        if titres.get('nombre_h1') == 0:
            recommendations.append("üè∑Ô∏è IMPORTANT: Ajouter un titre H1 unique et descriptif")
        elif titres.get('nombre_h1') > 1:
            recommendations.append("‚ö†Ô∏è Utiliser un seul H1 par page (actuellement {})".format(titres['nombre_h1']))
        
        if not titres.get('hierarchie_correcte'):
            recommendations.append("üìä Corriger la hi√©rarchie des titres (H1‚ÜíH2‚ÜíH3...)")
    
    # M√©tadonn√©es
    if 'metadonnees' in analyse_structure:
        meta = analyse_structure['metadonnees']
        
        if meta.get('qualite_titre') == 'manquant':
            recommendations.append("üìù CRITIQUE: Ajouter un titre de page (balise title)")
        elif meta.get('qualite_titre') in ['trop court', 'trop long']:
            recommendations.append("üìè Optimiser le titre : viser 30-60 caract√®res (actuellement {})".format(meta.get('longueur_titre')))
        
        if meta.get('qualite_description') == 'manquant':
            recommendations.append("üìÑ Ajouter une meta description attractive de 150-160 caract√®res")
        elif meta.get('qualite_description') in ['trop court', 'trop long']:
            recommendations.append("üìê Ajuster la meta description : viser 150-160 caract√®res")
        
        if not meta.get('url_canonical'):
            recommendations.append("üîó Ajouter une URL canonique pour √©viter le contenu dupliqu√©")
    
    # Images
    if 'images' in analyse_structure:
        images = analyse_structure['images']
        
        if images.get('couverture_alt_pourcentage', 0) < 80:
            recommendations.append("üñºÔ∏è Ajouter des attributs alt √† toutes les images ({:.0f}% actuellement)".format(images.get('couverture_alt_pourcentage', 0)))
        
        if images.get('alt_vides', 0) > 0:
            recommendations.append("‚úèÔ∏è Remplir les attributs alt vides des images")
    
    # Donn√©es structur√©es
    if 'donnees_structurees' in analyse_structure:
        schema = analyse_structure['donnees_structurees']
        
        if not schema.get('json_ld_present') and not schema.get('microdata_present'):
            recommendations.append("üèóÔ∏è Impl√©menter des donn√©es structur√©es (JSON-LD) pour am√©liorer l'affichage dans les r√©sultats")
    
    # Crawlabilit√©
    if 'crawlabilite' in analyse_structure:
        crawl = analyse_structure['crawlabilite']
        
        if crawl.get('noindex'):
            recommendations.append("üö´ ATTENTION: Page marqu√©e noindex - elle ne sera pas index√©e")
        
        if crawl.get('nombre_liens_internes', 0) < 3:
            recommendations.append("üîó Am√©liorer le maillage interne : ajouter plus de liens vers d'autres pages")
    
    return recommendations[:5]


def generer_recommandations_performance(analyse_performance: Dict[str, Any]) -> List[str]:
    """G√©n√®re des recommandations pour la performance"""
    recommendations = []
    
    # Core Web Vitals
    if 'core_web_vitals' in analyse_performance:
        cwv = analyse_performance['core_web_vitals']
        
        # Desktop
        if 'desktop' in cwv and not cwv['desktop'].get('erreur'):
            desktop = cwv['desktop']
            
            if desktop.get('LCP_ms', 0) > 2500:
                recommendations.append("üñ•Ô∏è Am√©liorer le LCP Desktop : r√©duire le temps de chargement du plus grand √©l√©ment")
            
            if desktop.get('INP_ms', 0) > 200:
                recommendations.append("‚ö° Optimiser l'interactivit√© Desktop : r√©duire le d√©lai de r√©ponse")
            
            if desktop.get('CLS_score', 0) > 0.1:
                recommendations.append("üìê R√©duire les d√©calages visuels Desktop : stabiliser la mise en page")
        
        # Mobile
        if 'mobile' in cwv and not cwv['mobile'].get('erreur'):
            mobile = cwv['mobile']
            
            if mobile.get('LCP_ms', 0) > 2500:
                recommendations.append("üì± Am√©liorer le LCP Mobile : optimiser pour les connexions lentes")
            
            if mobile.get('score_performance', 0) < 50:
                recommendations.append("üì± Performance mobile critique : optimiser pour les appareils mobiles")
    
    # Taille de page
    if 'taille_page' in analyse_performance:
        taille = analyse_performance['taille_page']
        
        if taille.get('taille_ko', 0) > 1000:
            recommendations.append("üíæ R√©duire la taille de la page : actuellement {:.1f} KB".format(taille.get('taille_ko', 0)))
    
    # Temps de r√©ponse
    if 'temps_reponse' in analyse_performance:
        temps = analyse_performance['temps_reponse']
        
        if temps.get('temps_reponse_ms', 0) > 1000:
            recommendations.append("‚è±Ô∏è Am√©liorer le temps de r√©ponse serveur : actuellement {} ms".format(temps.get('temps_reponse_ms', 0)))
    
    return recommendations[:4]  # Max 4 pour performance